import json

from py2neo import Graph

# Connect to Neo4j
graph = Graph("bolt://localhost:7688", auth=("neo4j", ""))


def get_connections_for_hash(hash_value):
    query = """
    MATCH (file:MalwareFile {sha256: $hash_value})
    OPTIONAL MATCH (file)-[:HAS_NAME]->(name:MalwareName)
    OPTIONAL MATCH (file)-[:HAS_TAG]->(tag:MalwareTag)
    OPTIONAL MATCH (file)-[:HAS_THREAT_LABEL]->(threat_label:ThreatLabel)
    OPTIONAL MATCH (file)-[:HAS_POPULAR_THREAT_NAME]->(threat_name:PopularThreatName)
    OPTIONAL MATCH (file)-[:HAS_POPULAR_THREAT_CATEGORY]->(threat_category:PopularThreatCategory)
    OPTIONAL MATCH (file)-[:ANALYZED_BY]->(analysis:AnalysisResult)
    OPTIONAL MATCH (file)-[:HAS_VBA_INFO]->(vba_info:VBAInfo)
    OPTIONAL MATCH (vba_info)-[:CONTAINS_STRING]->(vba_string:VBAString)
    OPTIONAL MATCH (file)-[:HAS_TOTAL_VOTES]->(total_votes:TotalVotes)
    OPTIONAL MATCH (file)-[:HAS_ANALYSIS_STATS]->(analysis_stats:AnalysisStats)
    RETURN file, 
           collect(DISTINCT name) as names, 
           collect(DISTINCT tag) as tags, 
           threat_label, 
           collect(DISTINCT threat_name) as threat_names, 
           collect(DISTINCT threat_category) as threat_categories, 
           collect(DISTINCT analysis) as analyses, 
           vba_info, 
           collect(DISTINCT vba_string) as vba_strings, 
           total_votes, 
           analysis_stats
    """
    result = graph.run(query, hash_value=hash_value)
    connections = []
    for record in result:
        connections.append(
            {
                "file": dict(record["file"]),
                "names": [dict(name) for name in record["names"] if name],
                "tags": [dict(tag) for tag in record["tags"] if tag],
                "threat_label": (
                    dict(record["threat_label"]) if record["threat_label"] else None
                ),
                "threat_names": [
                    dict(threat_name)
                    for threat_name in record["threat_names"]
                    if threat_name
                ],
                "threat_categories": [
                    dict(threat_category)
                    for threat_category in record["threat_categories"]
                    if threat_category
                ],
                "analyses": [
                    dict(analysis) for analysis in record["analyses"] if analysis
                ],
                "vba_info": dict(record["vba_info"]) if record["vba_info"] else None,
                "vba_strings": [
                    dict(vba_string)
                    for vba_string in record["vba_strings"]
                    if vba_string
                ],
                "total_votes": (
                    dict(record["total_votes"]) if record["total_votes"] else None
                ),
                "analysis_stats": (
                    dict(record["analysis_stats"]) if record["analysis_stats"] else None
                ),
            }
        )
    return connections


# Function to pretty print the connections
def print_connections(connections):
    for connection in connections:
        print(json.dumps(connection, indent=4))


# Query 1: Malware che condividono gli stessi tag
def get_malware_by_common_tags():
    query = """
    MATCH (tag:MalwareTag)<-[:HAS_TAG]-(file1:MalwareFile),
          (tag)<-[:HAS_TAG]-(file2:MalwareFile)
    WHERE file1 <> file2
    RETURN tag.tag as tag, collect(DISTINCT file1.sha256) as malware_files
    ORDER BY tag
    """
    result = graph.run(query)
    common_tags = []
    for record in result:
        common_tags.append(
            {"tag": record["tag"], "malware_files": record["malware_files"]}
        )
    return common_tags


# Function to pretty print the common tags
def print_common_tags(common_tags):
    for tag_info in common_tags:
        print(json.dumps(tag_info, indent=4))


# Query 2: Malware analizzati dagli stessi motori di analisi
def get_malware_by_analysis_engine():
    query = """
    MATCH (engine:AnalysisEngine)<-[:ANALYZED_BY]-(file:MalwareFile)
    RETURN engine.name as engine_name, collect(DISTINCT file.sha256) as malware_files
    ORDER BY engine_name
    """
    result = graph.run(query)
    analysis_engines = []
    for record in result:
        analysis_engines.append(
            {
                "engine_name": record["engine_name"],
                "malware_files": record["malware_files"],
            }
        )
    return analysis_engines


# Function to pretty print the analysis engines
def print_analysis_engines(analysis_engines):
    for engine_info in analysis_engines:
        print(json.dumps(engine_info, indent=4))


# Query 3: Malware che condividono le stesse stringhe VBA
def get_malware_by_vba_strings():
    query = """
    MATCH (vba_string:VBAString)<-[:CONTAINS_STRING]-(vba_info:VBAInfo)<-[:HAS_VBA_INFO]-(file1:MalwareFile),
          (vba_string)<-[:CONTAINS_STRING]-(vba_info2:VBAInfo)<-[:HAS_VBA_INFO]-(file2:MalwareFile)
    WHERE file1 <> file2
    RETURN vba_string.string as vba_string, collect(DISTINCT file1.sha256) as malware_files
    ORDER BY vba_string
    """
    result = graph.run(query)
    common_vba_strings = []
    for record in result:
        common_vba_strings.append(
            {
                "vba_string": record["vba_string"],
                "malware_files": record["malware_files"],
            }
        )
    return common_vba_strings


# Function to pretty print the common VBA strings
def print_common_vba_strings(common_vba_strings):
    for vba_info in common_vba_strings:
        print(json.dumps(vba_info, indent=4))


# Query 4: Malware con le stesse classificazioni di minaccia
def get_malware_by_threat_classification():
    query = """
    MATCH (threat_name:PopularThreatName)<-[:HAS_POPULAR_THREAT_NAME]-(file1:MalwareFile),
          (threat_name)<-[:HAS_POPULAR_THREAT_NAME]-(file2:MalwareFile)
    WHERE file1 <> file2
    RETURN threat_name.name as threat_name, collect(DISTINCT file1.sha256) as malware_files
    ORDER BY threat_name
    """
    result = graph.run(query)
    common_threats = []
    for record in result:
        common_threats.append(
            {
                "threat_name": record["threat_name"],
                "malware_files": record["malware_files"],
            }
        )
    return common_threats


# Function to pretty print the common threat classifications
def print_common_threats(common_threats):
    for threat_info in common_threats:
        print(json.dumps(threat_info, indent=4))


# Query 5: Malware con voti totali simili
def get_malware_by_total_votes():
    query = """
    MATCH (file:MalwareFile)-[:HAS_TOTAL_VOTES]->(votes:TotalVotes)
    RETURN votes.harmless as harmless_votes, votes.malicious as malicious_votes, collect(DISTINCT file.sha256) as malware_files
    ORDER BY harmless_votes, malicious_votes
    """
    result = graph.run(query)
    total_votes = []
    for record in result:
        total_votes.append(
            {
                "harmless_votes": record["harmless_votes"],
                "malicious_votes": record["malicious_votes"],
                "malware_files": record["malware_files"],
            }
        )
    return total_votes


# Function to pretty print the total votes
def print_total_votes(total_votes):
    for vote_info in total_votes:
        print(json.dumps(vote_info, indent=4))


# Example usage for each function
hash_value = "5d8c7e3af3963f556c7a4f1b9a368c2bd0645da44cbe6afdc85575143a0e2d66"
connections = get_connections_for_hash(hash_value)
print("Connections for hash:")
print_connections(connections)

common_tags = get_malware_by_common_tags()
print("Common tags:")
print_common_tags(common_tags)

analysis_engines = get_malware_by_analysis_engine()
print("Analysis engines:")
print_analysis_engines(analysis_engines)

common_vba_strings = get_malware_by_vba_strings()
print("Common VBA strings:")
print_common_vba_strings(common_vba_strings)


total_votes = get_malware_by_total_votes()
print("Total votes:")
print_total_votes(total_votes)

common_threats = get_malware_by_threat_classification()
print("Common threat classifications:")
print_common_threats(common_threats)
