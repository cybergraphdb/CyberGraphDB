import json
import os
import logging
from py2neo import Graph, Node, Relationship

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Connect to Neo4j
graph = Graph("bolt://localhost:7688", auth=("neo4j", ""))

# Main directory path
main_dir = "Retrieve_HASH/FILTER_TARGET_HASHES/"  # Replace with the correct path

# Function to create nodes and relationships from a JSON file
def create_nodes_from_json(file_path):
    try:
        with open(file_path, "r") as file:
            data = json.load(file)

        # Extract main data
        try:
            file_id = data["data"]["id"]
            attributes = data["data"]["attributes"]
            logging.info(f"Processing file ID: {file_id}")

            # Check if the node already exists
            existing_file_node = graph.nodes.match("MalwareFile", id=file_id).first()
            if existing_file_node:
                logging.info(f"MalwareFile {file_id} already exists in the database.")
                return

            # Create the main file node
            file_node = Node(
                "MalwareFile",
                id=file_id,
                sha256=attributes.get("sha256", ""),
                size=attributes.get("size", ""),
                type_description=attributes.get("type_description", ""),
                last_modification_date=attributes.get("last_modification_date", ""),
                first_submission_date=attributes.get("first_submission_date", ""),
                times_submitted=attributes.get("times_submitted", 0),
            )
            graph.create(file_node)

            # Create nodes and relationships for 'names'
            for name in attributes.get("names", []):
                name_node = graph.nodes.match("MalwareName", name=name).first()
                if not name_node:
                    name_node = Node("MalwareName", name=name)
                    graph.create(name_node)
                relation = Relationship(file_node, "HAS_NAME", name_node)
                graph.create(relation)

            # Create nodes and relationships for 'type_tags'
            for tag in attributes.get("type_tags", []):
                tag_node = graph.nodes.match("MalwareTag", tag=tag).first()
                if not tag_node:
                    tag_node = Node("MalwareTag", tag=tag)
                    graph.create(tag_node)
                relation = Relationship(file_node, "HAS_TAG", tag_node)
                graph.create(relation)

            # Create nodes and relationships for 'popular_threat_classification'
            threat_label = attributes.get("popular_threat_classification", {}).get("suggested_threat_label", "")
            threat_label_node = graph.nodes.match("ThreatLabel", label=threat_label).first()
            if not threat_label_node:
                threat_label_node = Node("ThreatLabel", label=threat_label)
                graph.create(threat_label_node)
            relation = Relationship(file_node, "HAS_THREAT_LABEL", threat_label_node)
            graph.create(relation)

            for threat in attributes.get("popular_threat_classification", {}).get("popular_threat_name", []):
                threat_name_node = graph.nodes.match("PopularThreatName", name=threat["value"]).first()
                if not threat_name_node:
                    threat_name_node = Node("PopularThreatName", name=threat["value"], count=threat.get("count", 0))
                    graph.create(threat_name_node)
                relation = Relationship(file_node, "HAS_POPULAR_THREAT_NAME", threat_name_node)
                graph.create(relation)

            for category in attributes.get("popular_threat_classification", {}).get("popular_threat_category", []):
                threat_category_node = graph.nodes.match("PopularThreatCategory", category=category["value"]).first()
                if not threat_category_node:
                    threat_category_node = Node("PopularThreatCategory", category=category["value"], count=category.get("count", 0))
                    graph.create(threat_category_node)
                relation = Relationship(file_node, "HAS_POPULAR_THREAT_CATEGORY", threat_category_node)
                graph.create(relation)

            # Create nodes and relationships for 'last_analysis_results'
            for engine, result in attributes.get("last_analysis_results", {}).items():
                engine_node = graph.nodes.match("AnalysisEngine", name=engine).first()
                if not engine_node:
                    engine_node = Node("AnalysisEngine", name=engine)
                    graph.create(engine_node)
                analysis_result_node = Node(
                    "AnalysisResult",
                    engine_name=engine,
                    category=result.get("category", ""),
                    result=result.get("result", ""),
                    method=result.get("method", ""),
                    engine_version=result.get("engine_version", ""),
                    engine_update=result.get("engine_update", ""),
                )
                graph.create(analysis_result_node)
                relation = Relationship(file_node, "ANALYZED_BY", analysis_result_node)
                graph.create(relation)

            # Create nodes and relationships for 'vba_info'
            if "vba_info" in attributes:
                vba_info = attributes["vba_info"]
                vba_node = Node("VBAInfo")
                graph.create(vba_node)
                relation = Relationship(file_node, "HAS_VBA_INFO", vba_node)
                graph.create(relation)

                for string in vba_info.get("strings", []):
                    string_node = graph.nodes.match("VBAString", string=string).first()
                    if not string_node:
                        string_node = Node("VBAString", string=string)
                        graph.create(string_node)
                    relation = Relationship(vba_node, "CONTAINS_STRING", string_node)
                    graph.create(relation)

            # Create node for 'total_votes'
            total_votes_node = Node(
                "TotalVotes",
                harmless=attributes.get("total_votes", {}).get("harmless", 0),
                malicious=attributes.get("total_votes", {}).get("malicious", 0),
            )
            graph.create(total_votes_node)
            relation = Relationship(file_node, "HAS_TOTAL_VOTES", total_votes_node)
            graph.create(relation)

            # Create node for 'last_analysis_stats'
            analysis_stats = attributes.get("last_analysis_stats", {})
            stats_node = Node(
                "AnalysisStats",
                harmless=analysis_stats.get("harmless", 0),
                type_unsupported=analysis_stats.get("type-unsupported", 0),
                suspicious=analysis_stats.get("suspicious", 0),
                confirmed_timeout=analysis_stats.get("confirmed-timeout", 0),
                timeout=analysis_stats.get("timeout", 0),
                failure=analysis_stats.get("failure", 0),
                malicious=analysis_stats.get("malicious", 0),
                undetected=analysis_stats.get("undetected", 0),
            )
            graph.create(stats_node)
            relation = Relationship(file_node, "HAS_ANALYSIS_STATS", stats_node)
            graph.create(relation)

        except Exception as e:
            logging.error(f"Exception while processing file {file_path}: {e}")

    except Exception as e:
        logging.error(f"Exception while reading file {file_path}: {e}")


# Traverse directories and process JSON files
for root, dirs, files in os.walk(main_dir):
    for file in files:
        if not (file.endswith(".txt") or file.endswith(".py")):
            file_path = os.path.join(root, file)
            create_nodes_from_json(file_path)

logging.info("Import complete.")
