import pandas as pd
import plotly.express as px
import streamlit as st
from py2neo import Graph
from sklearn.cluster import KMeans


# Function to measure the execution time of queries
def measure_query_time(query_function, *args):
    start_time = time.time()
    result = query_function(*args)
    end_time = time.time()
    execution_time = end_time - start_time
    return execution_time, result


# Connect to Neo4j
graph = Graph("bolt://localhost:7688", auth=("neo4j", "scottdirT98"))


# Define the queries
def get_connections_for_hash(hash_value):
    query = """
    MATCH (file:MalwareFile {sha256: $hash_value})
    OPTIONAL MATCH (file)-[:HAS_NAME]->(name:MalwareName)
    OPTIONAL MATCH (file)-[:HAS_TAG]->(tag:MalwareTag)
    OPTIONAL MATCH (file)-[:HAS_THREAT_LABEL]->(threat_label:ThreatLabel)
    OPTIONAL MATCH (file)-[:HAS_POPULAR_THREAT_NAME]->(threat_name:PopularThreatName)
    OPTIONAL MATCH (file)-[:HAS_POPULAR_THREAT_CATEGORY]->(threat_category:PopularThreatCategory)
    OPTIONAL MATCH (file)-[:ANALYZED_BY]->(analysis:AnalysisResult)
    OPTIONAL MATCH (file)-[:HAS_VBA_INFO]->(vba_info:VBAInfo)
    OPTIONAL MATCH (vba_info)-[:CONTAINS_STRING]->(vba_string:VBAString)
    OPTIONAL MATCH (file)-[:HAS_TOTAL_VOTES]->(total_votes:TotalVotes)
    OPTIONAL MATCH (file)-[:HAS_ANALYSIS_STATS]->(analysis_stats:AnalysisStats)
    RETURN file, 
           collect(DISTINCT name) as names, 
           collect(DISTINCT tag) as tags, 
           threat_label, 
           collect(DISTINCT threat_name) as threat_names, 
           collect(DISTINCT threat_category) as threat_categories, 
           collect(DISTINCT analysis) as analyses, 
           vba_info, 
           collect(DISTINCT vba_string) as vba_strings, 
           total_votes, 
           analysis_stats
    """
    result = graph.run(query, hash_value=hash_value)
    connections = []
    for record in result:
        connections.append(
            {
                "file": dict(record["file"]),
                "names": [dict(name) for name in record["names"] if name],
                "tags": [dict(tag) for tag in record["tags"] if tag],
                "threat_label": (
                    dict(record["threat_label"]) if record["threat_label"] else None
                ),
                "threat_names": [
                    dict(threat_name)
                    for threat_name in record["threat_names"]
                    if threat_name
                ],
                "threat_categories": [
                    dict(threat_category)
                    for threat_category in record["threat_categories"]
                    if threat_category
                ],
                "analyses": [
                    dict(analysis) for analysis in record["analyses"] if analysis
                ],
                "vba_info": dict(record["vba_info"]) if record["vba_info"] else None,
                "vba_strings": [
                    dict(vba_string)
                    for vba_string in record["vba_strings"]
                    if vba_string
                ],
                "total_votes": (
                    dict(record["total_votes"]) if record["total_votes"] else None
                ),
                "analysis_stats": (
                    dict(record["analysis_stats"]) if record["analysis_stats"] else None
                ),
            }
        )
    return connections


def get_malware_by_common_tags():
    query = """
    MATCH (tag:MalwareTag)<-[:HAS_TAG]-(file1:MalwareFile),
          (tag)<-[:HAS_TAG]-(file2:MalwareFile)
    WHERE file1 <> file2
    RETURN tag.tag as tag, collect(DISTINCT file1.sha256) as malware_files
    ORDER BY tag
    """
    result = graph.run(query)
    common_tags = []
    for record in result:
        common_tags.append(
            {"tag": record["tag"], "malware_files": record["malware_files"]}
        )
    return common_tags


def get_malware_by_analysis_engine():
    query = """
    MATCH (engine:AnalysisEngine)<-[:ANALYZED_BY]-(file:MalwareFile)
    RETURN engine.name as engine_name, collect(DISTINCT file.sha256) as malware_files
    ORDER BY engine_name
    """
    result = graph.run(query)
    analysis_engines = []
    for record in result:
        analysis_engines.append(
            {
                "engine_name": record["engine_name"],
                "malware_files": record["malware_files"],
            }
        )
    return analysis_engines


def get_malware_by_vba_strings():
    query = """
    MATCH (vba_string:VBAString)<-[:CONTAINS_STRING]-(vba_info:VBAInfo)<-[:HAS_VBA_INFO]-(file1:MalwareFile),
          (vba_string)<-[:CONTAINS_STRING]-(vba_info2:VBAInfo)<-[:HAS_VBA_INFO]-(file2:MalwareFile)
    WHERE file1 <> file2
    RETURN vba_string.string as vba_string, collect(DISTINCT file1.sha256) as malware_files
    ORDER BY vba_string
    """
    result = graph.run(query)
    common_vba_strings = []
    for record in result:
        common_vba_strings.append(
            {
                "vba_string": record["vba_string"],
                "malware_files": record["malware_files"],
            }
        )
    return common_vba_strings


def get_malware_by_threat_classification():
    query = """
    MATCH (threat_name:PopularThreatName)<-[:HAS_POPULAR_THREAT_NAME]-(file1:MalwareFile),
          (threat_name)<-[:HAS_POPULAR_THREAT_NAME]-(file2:MalwareFile)
    WHERE file1 <> file2
    RETURN threat_name.name as threat_name, collect(DISTINCT file1.sha256) as malware_files
    ORDER BY threat_name
    """
    result = graph.run(query)
    common_threats = []
    for record in result:
        common_threats.append(
            {
                "threat_name": record["threat_name"],
                "malware_files": record["malware_files"],
            }
        )
    return common_threats


def get_malware_by_total_votes():
    query = """
    MATCH (file:MalwareFile)-[:HAS_TOTAL_VOTES]->(votes:TotalVotes)
    RETURN votes.harmless as harmless_votes, votes.malicious as malicious_votes, collect(DISTINCT file.sha256) as malware_files
    ORDER BY harmless_votes, malicious_votes
    """
    result = graph.run(query)
    total_votes = []
    for record in result:
        total_votes.append(
            {
                "harmless_votes": record["harmless_votes"],
                "malicious_votes": record["malicious_votes"],
                "malware_files": record["malware_files"],
            }
        )
    return total_votes


def get_malware_with_most_names():
    query = """
    MATCH (file:MalwareFile)-[:HAS_NAME]->(name:MalwareName)
    RETURN file.sha256 as malware_file, count(name) as name_count
    ORDER BY name_count DESC
    LIMIT 10
    """
    result = graph.run(query)
    most_names = []
    for record in result:
        most_names.append(
            {"malware_file": record["malware_file"], "name_count": record["name_count"]}
        )
    return most_names


def get_most_analyzed_malware():
    query = """
    MATCH (file:MalwareFile)-[:ANALYZED_BY]->(analysis:AnalysisResult)
    RETURN file.sha256 as malware_file, count(analysis) as analysis_count
    ORDER BY analysis_count DESC
    LIMIT 10
    """
    result = graph.run(query)
    most_analyzed = []
    for record in result:
        most_analyzed.append(
            {
                "malware_file": record["malware_file"],
                "analysis_count": record["analysis_count"],
            }
        )
    return most_analyzed


def get_most_used_analysis_engines():
    query = """
    MATCH (engine:AnalysisEngine)<-[:ANALYZED_BY]-(file:MalwareFile)
    RETURN engine.name as engine_name, count(file) as analysis_count
    ORDER BY analysis_count DESC
    LIMIT 10
    """
    result = graph.run(query)
    most_used_engines = []
    for record in result:
        most_used_engines.append(
            {
                "engine_name": record["engine_name"],
                "analysis_count": record["analysis_count"],
            }
        )
    return most_used_engines


def get_malware_with_most_unique_vba_strings():
    query = """
    MATCH (vba_string:VBAString)<-[:CONTAINS_STRING]-(vba_info:VBAInfo)<-[:HAS_VBA_INFO]-(file:MalwareFile)
    RETURN file.sha256 as malware_file, count(DISTINCT vba_string) as unique_vba_string_count
    ORDER BY unique_vba_string_count DESC
    LIMIT 10
    """
    result = graph.run(query)
    most_unique_vba_strings = []
    for record in result:
        most_unique_vba_strings.append(
            {
                "malware_file": record["malware_file"],
                "unique_vba_string_count": record["unique_vba_string_count"],
            }
        )
    return most_unique_vba_strings


def get_malware_with_most_threat_classifications():
    query = """
    MATCH (file:MalwareFile)-[:HAS_POPULAR_THREAT_NAME]->(threat_name:PopularThreatName)
    RETURN file.sha256 as malware_file, count(threat_name) as threat_classification_count
    ORDER BY threat_classification_count DESC
    LIMIT 10
    """
    result = graph.run(query)
    most_threat_classifications = []
    for record in result:
        most_threat_classifications.append(
            {
                "malware_file": record["malware_file"],
                "threat_classification_count": record["threat_classification_count"],
            }
        )
    return most_threat_classifications


def get_malware_by_name_in_tags_or_threats(name):
    query = """
    MATCH (file:MalwareFile)
    OPTIONAL MATCH (file)-[:HAS_TAG]->(tag:MalwareTag)
    OPTIONAL MATCH (file)-[:HAS_NAME]->(malware_name:MalwareName)
    OPTIONAL MATCH (file)-[:HAS_THREAT_LABEL]->(threat_label:ThreatLabel)
    OPTIONAL MATCH (file)-[:HAS_POPULAR_THREAT_NAME]->(threat_name:PopularThreatName)
    OPTIONAL MATCH (file)-[:HAS_POPULAR_THREAT_CATEGORY]->(threat_category:PopularThreatCategory)
    WITH file, tag, malware_name, threat_label, threat_name, threat_category
    WHERE (tag.tag IS NOT NULL AND tag.tag CONTAINS $name)
       OR (malware_name.name IS NOT NULL AND malware_name.name CONTAINS $name)
       OR (threat_label.name IS NOT NULL AND threat_label.name CONTAINS $name)
       OR (threat_name.name IS NOT NULL AND threat_name.name CONTAINS $name)
       OR (threat_category.name IS NOT NULL AND threat_category.name CONTAINS $name)
    RETURN file.sha256 as malware_file, 
           collect(DISTINCT tag.tag) as tags, 
           collect(DISTINCT malware_name.name) as names,
           collect(DISTINCT threat_label.name) as threat_labels, 
           collect(DISTINCT threat_name.name) as threat_names,
           collect(DISTINCT threat_category.name) as threat_categories
    """
    result = graph.run(query, name=name)
    malware_list = []
    for record in result:
        malware_list.append(
            {
                "malware_file": record["malware_file"],
                "tags": record["tags"],
                "names": record["names"],
                "threat_labels": record["threat_labels"],
                "threat_names": record["threat_names"],
                "threat_categories": record["threat_categories"],
            }
        )
    return malware_list


def get_most_recent_malware():
    query = """
    MATCH (file:MalwareFile)
    RETURN file.sha256 as malware_file, file.last_submission_date as last_submission_date
    ORDER BY file.last_submission_date DESC
    LIMIT 10
    """
    result = graph.run(query)
    most_recent = []
    for record in result:
        most_recent.append(
            {
                "malware_file": record["malware_file"],
                "last_submission_date": record["last_submission_date"],
            }
        )
    return most_recent


def get_most_malicious_votes():
    query = """
    MATCH (file:MalwareFile)-[:HAS_TOTAL_VOTES]->(votes:TotalVotes)
    RETURN file.sha256 as malware_file, votes.malicious as malicious_votes
    ORDER BY votes.malicious DESC
    LIMIT 10
    """
    result = graph.run(query)
    most_malicious_votes = []
    for record in result:
        most_malicious_votes.append(
            {
                "malware_file": record["malware_file"],
                "malicious_votes": record["malicious_votes"],
            }
        )
    return most_malicious_votes


def get_largest_malware():
    query = """
    MATCH (file:MalwareFile)
    RETURN file.sha256 as malware_file, file.size as size
    ORDER BY file.size DESC
    LIMIT 10
    """
    result = graph.run(query)
    largest_malware = []
    for record in result:
        largest_malware.append(
            {"malware_file": record["malware_file"], "size": record["size"]}
        )
    return largest_malware


def get_most_submitted_malware():
    query = """
    MATCH (file:MalwareFile)
    RETURN file.sha256 as malware_file, file.times_submitted as times_submitted
    ORDER BY file.times_submitted DESC
    LIMIT 10
    """
    result = graph.run(query)
    most_submitted = []
    for record in result:
        most_submitted.append(
            {
                "malware_file": record["malware_file"],
                "times_submitted": record["times_submitted"],
            }
        )
    return most_submitted


# Function to get malware data for clustering
def get_malware_data():
    query = """
    MATCH (file:MalwareFile)
    OPTIONAL MATCH (file)-[:HAS_TAG]->(tag:MalwareTag)
    OPTIONAL MATCH (file)-[:HAS_NAME]->(name:MalwareName)
    OPTIONAL MATCH (file)-[:HAS_POPULAR_THREAT_NAME]->(threat_name:PopularThreatName)
    OPTIONAL MATCH (file)-[:HAS_POPULAR_THREAT_CATEGORY]->(threat_category:PopularThreatCategory)
    RETURN file.sha256 as malware_file, 
           file.size as size, 
           collect(DISTINCT tag.tag) as tags, 
           collect(DISTINCT name.name) as names, 
           collect(DISTINCT threat_name.name) as threat_names, 
           collect(DISTINCT threat_category.name) as threat_categories
    LIMIT 1000
    """
    result = graph.run(query)
    data = []
    for record in result:
        data.append(
            {
                "malware_file": record["malware_file"],
                "size": record["size"],
                "tags": record["tags"],
                "names": record["names"],
                "threat_names": record["threat_names"],
                "threat_categories": record["threat_categories"],
            }
        )
    return pd.DataFrame(data)


# Function to perform clustering
def cluster_malware(data):
    # Preprocessing: Convert lists to strings
    data["tags_str"] = data["tags"].apply(lambda x: " ".join(x))
    data["names_str"] = data["names"].apply(lambda x: " ".join(x))
    data["threat_names_str"] = data["threat_names"].apply(lambda x: " ".join(x))
    data["threat_categories_str"] = data["threat_categories"].apply(
        lambda x: " ".join(x)
    )

    # Create a feature set
    features = pd.DataFrame()
    features["size"] = data["size"]

    # One-hot encode tags, names, threat names, and threat categories
    tags_dummies = data["tags_str"].str.get_dummies(sep=" ")
    names_dummies = data["names_str"].str.get_dummies(sep=" ")
    threat_names_dummies = data["threat_names_str"].str.get_dummies(sep=" ")
    threat_categories_dummies = data["threat_categories_str"].str.get_dummies(sep=" ")

    features = pd.concat(
        [
            features,
            tags_dummies,
            names_dummies,
            threat_names_dummies,
            threat_categories_dummies,
        ],
        axis=1,
    )

    # Clustering
    kmeans = KMeans(n_clusters=5, random_state=0).fit(features)
    data["cluster"] = kmeans.labels_

    return data


# Function to plot clusters using plotly
def plot_clusters(data):
    fig = px.scatter(
        data,
        x="size",
        y="malware_file",
        color="cluster",
        title="Malware Clusters",
        labels={"size": "Size", "malware_file": "Malware File", "cluster": "Cluster"},
        hover_data=["tags", "names", "threat_names", "threat_categories"],
    )
    st.plotly_chart(fig)


# Function to plot clusters using plotly

# Streamlit UI
st.title("Malware Information Explorer")

# Query selection
query_options = [
    "Connections for Hash",
    "Malware by Common Tags",
    "Malware by Analysis Engines",
    "Malware by Common VBA Strings",
    "Malware by Threat Classifications",
    "Malware by Total Votes",
    "Malware with Most Names",
    "Most Analyzed Malware",
    "Most Used Analysis Engines",
    "Malware with Most Unique VBA Strings",
    "Malware with Most Threat Classifications",
    "Malware by Name in Tags or Threats",
    "Most Recent Malware",
    "Malware with Most Malicious Votes",
    "Largest Malware",
    "Most Submitted Malware",
    "Cluster Similar Malware",
]
import time


# Function to measure the execution time of queries
def measure_query_time(query_function, *args):
    start_time = time.time()
    result = query_function(*args)
    end_time = time.time()
    execution_time = end_time - start_time
    return execution_time, result


# Function to classify queries based on difficulty
def classify_queries(queries):
    easy_queries = [
        "get_malware_with_most_names",
        "get_most_analyzed_malware",
        "get_most_used_analysis_engines",
        "get_most_recent_malware",
        "get_largest_malware",
        "get_most_submitted_malware",
    ]

    medium_queries = [
        "get_connections_for_hash",
        "get_malware_by_common_tags",
        "get_malware_by_analysis_engine",
        "get_malware_by_common_vba_strings",
        "get_malware_by_threat_classification",
        "get_malware_by_total_votes",
        "get_malware_with_most_unique_vba_strings",
        "get_malware_with_most_threat_classifications",
        "get_most_malicious_votes",
    ]

    hard_queries = ["get_malware_by_name_in_tags_or_threats", "get_malware_data"]

    classified_queries = {
        "easy": easy_queries,
        "medium": medium_queries,
        "hard": hard_queries,
    }

    return classified_queries


# Dictionary to store query functions
query_functions = {
    "get_connections_for_hash": get_connections_for_hash,
    "get_malware_by_common_tags": get_malware_by_common_tags,
    "get_malware_by_analysis_engine": get_malware_by_analysis_engine,
    "get_malware_by_common_vba_strings": get_malware_by_vba_strings,
    "get_malware_by_threat_classification": get_malware_by_threat_classification,
    "get_malware_by_total_votes": get_malware_by_total_votes,
    "get_malware_with_most_names": get_malware_with_most_names,
    "get_most_analyzed_malware": get_most_analyzed_malware,
    "get_most_used_analysis_engines": get_most_used_analysis_engines,
    "get_malware_with_most_unique_vba_strings": get_malware_with_most_unique_vba_strings,
    "get_malware_with_most_threat_classifications": get_malware_with_most_threat_classifications,
    "get_malware_by_name_in_tags_or_threats": get_malware_by_name_in_tags_or_threats,
    "get_most_recent_malware": get_most_recent_malware,
    "get_most_malicious_votes": get_most_malicious_votes,
    "get_largest_malware": get_largest_malware,
    "get_most_submitted_malware": get_most_submitted_malware,
    "get_malware_data": get_malware_data,
}

# Measure execution time for each query
execution_times = {}

for query_name, query_function in query_functions.items():
    if query_name == "get_connections_for_hash":
        execution_time, _ = measure_query_time(query_function, "some_hash_value")
    elif query_name == "get_malware_by_name_in_tags_or_threats":
        execution_time, _ = measure_query_time(query_function, "some_name")
    else:
        execution_time, _ = measure_query_time(query_function)
    execution_times[query_name] = execution_time

# Classify the queries
classified_queries = classify_queries(query_functions.keys())

# Calculate average execution times for each difficulty level
average_times = {}
for level in classified_queries.keys():
    times = [execution_times[query] for query in classified_queries[level]]
    average_times[level] = sum(times) / len(times)


# Function to measure the execution time of queries
def measure_query_time(query_function, *args):
    start_time = time.time()
    result = query_function(*args)
    end_time = time.time()
    execution_time = end_time - start_time
    return execution_time, result


# Function to classify queries based on difficulty
def classify_queries(queries):
    easy_queries = [
        "get_malware_with_most_names",
        "get_most_analyzed_malware",
        "get_most_used_analysis_engines",
        "get_most_recent_malware",
        "get_largest_malware",
        "get_most_submitted_malware",
    ]

    medium_queries = [
        "get_connections_for_hash",
        "get_malware_by_common_tags",
        "get_malware_by_analysis_engine",
        "get_malware_by_common_vba_strings",
        "get_malware_by_threat_classification",
        "get_malware_by_total_votes",
        "get_malware_with_most_unique_vba_strings",
        "get_malware_with_most_threat_classifications",
        "get_most_malicious_votes",
    ]

    hard_queries = ["get_malware_by_name_in_tags_or_threats", "get_malware_data"]

    classified_queries = {
        "easy": easy_queries,
        "medium": medium_queries,
        "hard": hard_queries,
    }

    return classified_queries


# Dictionary to store query functions
query_functions = {
    "get_connections_for_hash": get_connections_for_hash,
    "get_malware_by_common_tags": get_malware_by_common_tags,
    "get_malware_by_analysis_engine": get_malware_by_analysis_engine,
    "get_malware_by_common_vba_strings": get_malware_by_vba_strings,
    "get_malware_by_threat_classification": get_malware_by_threat_classification,
    "get_malware_by_total_votes": get_malware_by_total_votes,
    "get_malware_with_most_names": get_malware_with_most_names,
    "get_most_analyzed_malware": get_most_analyzed_malware,
    "get_most_used_analysis_engines": get_most_used_analysis_engines,
    "get_malware_with_most_unique_vba_strings": get_malware_with_most_unique_vba_strings,
    "get_malware_with_most_threat_classifications": get_malware_with_most_threat_classifications,
    "get_malware_by_name_in_tags_or_threats": get_malware_by_name_in_tags_or_threats,
    "get_most_recent_malware": get_most_recent_malware,
    "get_most_malicious_votes": get_most_malicious_votes,
    "get_largest_malware": get_largest_malware,
    "get_most_submitted_malware": get_most_submitted_malware,
    "get_malware_data": get_malware_data,
}

# Measure execution time for each query
execution_times = {}

for query_name, query_function in query_functions.items():
    if query_name == "get_connections_for_hash":
        execution_time, _ = measure_query_time(query_function, "some_hash_value")
    elif query_name == "get_malware_by_name_in_tags_or_threats":
        execution_time, _ = measure_query_time(query_function, "some_name")
    else:
        execution_time, _ = measure_query_time(query_function)
    execution_times[query_name] = execution_time

# Classify the queries
classified_queries = classify_queries(query_functions.keys())

# Calculate average execution times for each difficulty level
average_times = {}
for level in classified_queries.keys():
    times = [execution_times[query] for query in classified_queries[level]]
    average_times[level] = sum(times) / len(times)

# Display the results in a bar chart
import matplotlib.pyplot as plt

levels = list(average_times.keys())
times = list(average_times.values())

plt.figure(figsize=(10, 6))
plt.bar(levels, times, color=["green", "orange", "red"])
plt.xlabel("Difficulty Level")
plt.ylabel("Average Execution Time (seconds)")
plt.title("Average Execution Time for Each Difficulty Level")
plt.show()

st.pyplot(plt)
# query_selection = st.selectbox("Select Query", query_options)

# # Hash input for specific query
# if query_selection == "Connections for Hash":
#     hash_value = st.text_input("Enter SHA256 Hash", "")
#     if hash_value:
#         connections = get_connections_for_hash(hash_value)
#         if connections:
#             st.subheader("Connections")
#             st.json(connections)
#         else:
#             st.write("No connections found for this hash.")
# elif query_selection == "Malware by Name in Tags or Threats":
#     name = st.text_input("Enter Name", "")
#     if name:
#         malware_list = get_malware_by_name_in_tags_or_threats(name)
#         if malware_list:
#             st.subheader("Malware by Name in Tags or Threats")
#             st.json(malware_list)
#         else:
#             st.write("No malware found with this name in tags or threats.")
# elif query_selection == "Most Recent Malware":
#     if st.button("Execute Query"):
#         most_recent = get_most_recent_malware()
#         st.subheader("Most Recent Malware")
#         st.json(most_recent)
# elif query_selection == "Malware with Most Malicious Votes":
#     if st.button("Execute Query"):
#         most_malicious_votes = get_most_malicious_votes()
#         st.subheader("Malware with Most Malicious Votes")
#         st.json(most_malicious_votes)
# elif query_selection == "Largest Malware":
#     if st.button("Execute Query"):
#         largest_malware = get_largest_malware()
#         st.subheader("Largest Malware")
#         st.json(largest_malware)
# elif query_selection == "Most Submitted Malware":
#     if st.button("Execute Query"):
#         most_submitted = get_most_submitted_malware()
#         st.subheader("Most Submitted Malware")
#         st.json(most_submitted)
# else:
#     if query_selection == "Malware by Common Tags":
#         if st.button("Execute Query"):
#             common_tags = get_malware_by_common_tags()
#             st.subheader("Malware by Common Tags")
#             st.json(common_tags)
#     elif query_selection == "Malware by Analysis Engines":
#         if st.button("Execute Query"):
#             analysis_engines = get_malware_by_analysis_engine()
#             st.subheader("Malware by Analysis Engines")
#             st.json(analysis_engines)
#     elif query_selection == "Malware by Common VBA Strings":
#         if st.button("Execute Query"):
#             common_vba_strings = get_malware_by_vba_strings()
#             st.subheader("Malware by Common VBA Strings")
#             st.json(common_vba_strings)
#     elif query_selection == "Malware by Threat Classifications":
#         if st.button("Execute Query"):
#             common_threats = get_malware_by_threat_classification()
#             st.subheader("Malware by Threat Classifications")
#             st.json(common_threats)
#     elif query_selection == "Malware by Total Votes":
#         if st.button("Execute Query"):
#             total_votes = get_malware_by_total_votes()
#             st.subheader("Malware by Total Votes")
#             st.json(total_votes)
#     elif query_selection == "Malware with Most Names":
#         if st.button("Execute Query"):
#             most_names = get_malware_with_most_names()
#             st.subheader("Malware with Most Names")
#             st.json(most_names)
#     elif query_selection == "Most Analyzed Malware":
#         if st.button("Execute Query"):
#             most_analyzed = get_most_analyzed_malware()
#             st.subheader("Most Analyzed Malware")
#             st.json(most_analyzed)
#     elif query_selection == "Most Used Analysis Engines":
#         if st.button("Execute Query"):
#             most_used_engines = get_most_used_analysis_engines()
#             st.subheader("Most Used Analysis Engines")
#             st.json(most_used_engines)
#     elif query_selection == "Malware with Most Unique VBA Strings":
#         if st.button("Execute Query"):
#             most_unique_vba_strings = get_malware_with_most_unique_vba_strings()
#             st.subheader("Malware with Most Unique VBA Strings")
#             st.json(most_unique_vba_strings)
#     elif query_selection == "Malware with Most Threat Classifications":
#         if st.button("Execute Query"):
#             most_threat_classifications = get_malware_with_most_threat_classifications()
#             st.subheader("Malware with Most Threat Classifications")
#             st.json(most_threat_classifications)
#     elif query_selection == "Cluster Similar Malware":
#             data = get_malware_data()
#             clustered_data = cluster_malware(data)
#             st.subheader("Clustered Malware")
#             plot_clusters(clustered_data)
#             st.dataframe(clustered_data)
