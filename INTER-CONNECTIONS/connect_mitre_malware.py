from neo4j import GraphDatabase


class Neo4jHashAnalyzer:
    def __init__(self, uri, user, password):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))

    def close(self):
        self.driver.close()

    def run_query(self, query, parameters=None):
        with self.driver.session() as session:
            result = session.run(query, parameters)
            return result.data()

    def get_all_hashes(self):
        query = "MATCH (file:MalwareFile) RETURN file.sha256 AS hash_value"
        return self.run_query(query)

    def get_connections_for_hash(self, hash_value):
        query = """
        MATCH (file:MalwareFile {sha256: $hash_value})
        OPTIONAL MATCH (file)-[:HAS_NAME]->(name:MalwareName)
        OPTIONAL MATCH (file)-[:HAS_TAG]->(tag:MalwareTag)
        OPTIONAL MATCH (file)-[:HAS_THREAT_LABEL]->(threat_label:ThreatLabel)
        OPTIONAL MATCH (file)-[:HAS_POPULAR_THREAT_NAME]->(threat_name:PopularThreatName)
        OPTIONAL MATCH (file)-[:HAS_POPULAR_THREAT_CATEGORY]->(threat_category:PopularThreatCategory)
        OPTIONAL MATCH (file)-[:ANALYZED_BY]->(analysis:AnalysisResult)
        OPTIONAL MATCH (file)-[:HAS_VBA_INFO]->(vba_info:VBAInfo)
        OPTIONAL MATCH (vba_info)-[:CONTAINS_STRING]->(vba_string:VBAString)
        OPTIONAL MATCH (file)-[:HAS_TOTAL_VOTES]->(total_votes:TotalVotes)
        OPTIONAL MATCH (file)-[:HAS_ANALYSIS_STATS]->(analysis_stats:AnalysisStats)
        RETURN file, 
               collect(DISTINCT name) as names, 
               collect(DISTINCT tag) as tags, 
               threat_label, 
               collect(DISTINCT threat_name) as threat_names, 
               collect(DISTINCT threat_category) as threat_categories, 
               collect(DISTINCT analysis) as analyses, 
               vba_info, 
               collect(DISTINCT vba_string) as vba_strings, 
               total_votes, 
               analysis_stats
        """
        parameters = {"hash_value": hash_value}
        return self.run_query(query, parameters)

    def get_all_malware_names(self):
        query = "MATCH (malware:Malware) RETURN malware.name AS name"
        return self.run_query(query)

    def create_has_sample_relationship(self, malware_name, file_sha256):
        print(
            f"Creating SAMPLE_OF relationship between Malware: {malware_name} and MalwareFile: {file_sha256}"
        )
        check_malware_query = (
            "MATCH (malware:Malware {name: $malware_name}) RETURN malware"
        )
        check_file_query = "MATCH (file:MalwareFile {sha256: $file_sha256}) RETURN file"

        malware_exists = self.run_query(
            check_malware_query, {"malware_name": malware_name}
        )
        file_exists = self.run_query(check_file_query, {"file_sha256": file_sha256})

        if not malware_exists:
            print(f"Malware node with name {malware_name} does not exist.")
        if not file_exists:
            print(f"MalwareFile node with SHA256 {file_sha256} does not exist.")

        if malware_exists and file_exists:
            query = """
            MATCH (malware:Malware {name: $malware_name})
            MATCH (file:MalwareFile {sha256: $file_sha256})
            MERGE (file)-[r:SAMPLE_OF]->(malware)
            """
            parameters = {"malware_name": malware_name, "file_sha256": file_sha256}
            self.run_query(query, parameters)
        else:
            print(
                f"Cannot create relationship. Missing nodes for {malware_name} or {file_sha256}."
            )

    def analyze_all_hashes(self):
        all_hashes = [record["hash_value"] for record in self.get_all_hashes()]
        all_connections = []
        total_hashes = len(all_hashes)
        for index, hash_value in enumerate(all_hashes, start=1):
            print(f"Analyzing hash {index}/{total_hashes}: {hash_value}")
            connections = self.get_connections_for_hash(hash_value)
            all_connections.extend(connections)
            print(f"Completed analysis for hash {index}/{total_hashes}: {hash_value}")
        return all_connections

    def check_malware_names_in_connections(self, connections, malware_names):
        malware_names_lower = {name.lower(): name for name in malware_names}
        for connection in connections:
            file_sha256 = connection["file"]["sha256"]
            for lower_name, original_name in malware_names_lower.items():
                if self.is_malware_name_in_connection(lower_name, connection):
                    print(f"\n[!] Connection FOUND: {lower_name} {file_sha256}")
                    self.create_has_sample_relationship(original_name, file_sha256)

    def is_malware_name_in_connection(self, malware_name, connection):
        for key, value in connection.items():
            if isinstance(value, dict):
                if any(malware_name == str(v).lower() for v in value.values()):
                    return True
            elif isinstance(value, list):
                for item in value:
                    if isinstance(item, dict) and any(
                        malware_name == str(v).lower() for v in item.values()
                    ):
                        return True
        return False


if __name__ == "__main__":
    uri = "bolt://localhost:7688"
    user = "neo4j"
    password = ""

    analyzer = Neo4jHashAnalyzer(uri, user, password)
    print("Starting analysis of all hashes...")
    all_connections = analyzer.analyze_all_hashes()
    print("Completed analysis of all hashes.")

    malware_names = [record["name"] for record in analyzer.get_all_malware_names()]
    print("Checking malware names in connections...")
    analyzer.check_malware_names_in_connections(all_connections, malware_names)
    print("Completed checking malware names in connections.")

    analyzer.close()
